import { useState } from 'react';
import { toast } from 'sonner';
import { supabase } from '@/integrations/supabase/client';
import { getElementosUniversaisByMentor, getEspecialidadesByMentor } from '@/utils/cadastrarMentores';
import { useTemplateCache } from './useTemplateCache';

interface FluidaScriptData {
  // Dados do modo Akinator/Fluida
  tipo_conteudo?: string;
  objetivo?: string;
  canal?: string;
  estilo?: string;
  equipamento?: string;
  tema?: string;
  
  // Dados do modo Rocket/Elementos Universais
  elementos_escolhidos?: Record<string, string | string[]>;
  storytelling?: string;
  copywriting?: string;
  conhecimento_publico?: string;
  equipamentos?: string;
  analises_dados?: string;
  gatilhos_mentais?: string;
  logica_argumentativa?: string;
  premissas_educativas?: string;
  mapas_empatia?: string;
  headlines?: string;
  ferramentas_especificas?: string;
  modo?: string;
}

export const useFluidaScript = () => {
  const [results, setResults] = useState<any[]>([]);
  const [isGenerating, setIsGenerating] = useState(false);
  const [aiImproving, setAiImproving] = useState(false);
  const [showingTemplate, setShowingTemplate] = useState(false);
  const { getCached, setCached, generateInstantTemplate } = useTemplateCache();

  const generateScript = async (data: FluidaScriptData) => {
    console.log('üöÄ [useFluidaScript] Iniciando gera√ß√£o COM LOADING at√© IA finalizar');
    console.log('üìä [useFluidaScript] Dados recebidos:', data);
    
    setIsGenerating(true);
    setShowingTemplate(false);
    
    try {
      // NOVO: Aguardar IA completar antes de mostrar qualquer resultado
      const cachedScript = getCached(data.tema || '', data.equipamentos ? [data.equipamentos] : [], data.estilo);
      
      if (cachedScript && cachedScript.isAiGenerated) {
        console.log('üíæ [useFluidaScript] Usando cache IA encontrado');
        setResults([cachedScript.script]);
        setIsGenerating(false);
        
        toast.success('‚ö° Roteiro do cache!', {
          description: 'Roteiro IA encontrado no cache local.'
        });
        
        return cachedScript.script;
      }

      // Se n√£o tem cache IA, gerar com IA (SEM mostrar template antes)
      console.log('ü§ñ [useFluidaScript] Gerando diretamente com IA');
      const aiScript = await generateAiScript(data);
      
      return aiScript;

    } catch (error) {
      console.error('üî• [useFluidaScript] Erro cr√≠tico:', error);
      setIsGenerating(false);
      
      // Fallback: mostrar template apenas em caso de erro
      console.log('‚ö†Ô∏è [useFluidaScript] Erro IA, usando template como fallback');
      const fallbackScript = generateInstantTemplate(
        data.tema || '',
        data.equipamentos ? [data.equipamentos] : [],
        data.estilo
      );
      
      fallbackScript.ai_failed = true;
      setResults([fallbackScript]);
      
      toast.error('‚ùå Erro na IA', {
        description: 'Usando template como backup. Tente novamente.'
      });
      
      throw error;
    }
  };

  // Fun√ß√£o auxiliar para gera√ß√£o com IA (em background)
  const generateAiScript = async (data: FluidaScriptData) => {
    console.log('üöÄ [useFluidaScript] Iniciando gera√ß√£o de roteiro');
    console.log('üìä [useFluidaScript] Dados recebidos:', data);
    
    setIsGenerating(true);
    
    // Criar AbortController para timeout
    const controller = new AbortController();
    const timeoutId = setTimeout(() => {
      controller.abort();
      console.log('‚è∞ [useFluidaScript] Timeout de 60 segundos atingido');
    }, 60000); // 60 segundos timeout
    
    try {
      // Determinar qual modo est√° sendo usado
      const isRocketMode = data.modo === '10_elementos_universais' || data.elementos_escolhidos;
      const isFluida = !isRocketMode;
      
      console.log('üîç [useFluidaScript] Modo detectado:', isRocketMode ? 'Rocket (10 Elementos)' : 'Fluida (Akinator)');

      // Normalizar dados para formato compat√≠vel
      const normalizedData = isRocketMode ? {
        tipo_conteudo: data.tipo_conteudo || 'carrossel',
        objetivo: data.objetivo || 'atrair',
        canal: data.canal || 'instagram',
        estilo: inferirEstiloDoElementos(data) || 'criativo',
        equipamento: data.equipamentos || data.equipamento || '',
        tema: data.tema || ''
      } : {
        tipo_conteudo: data.tipo_conteudo || 'carrossel',
        objetivo: data.objetivo || 'atrair',
        canal: data.canal || 'instagram',
        estilo: data.estilo || 'criativo',
        equipamento: data.equipamento || '',
        tema: data.tema || ''
      };

      console.log('üîÑ [useFluidaScript] Dados normalizados:', normalizedData);

      // Inferir mentor baseado nos dados normalizados
      const mentorInferido = inferirMentor(normalizedData);
      const elementosUniversais = getElementosUniversaisByMentor(mentorInferido) || getDefaultElementos();
      const especialidades = getEspecialidadesByMentor(mentorInferido) || ['Criatividade', 'Inova√ß√£o'];

      console.log('üß† [useFluidaScript] Mentor inferido:', mentorInferido);
      console.log('üìä [useFluidaScript] Elementos universais:', elementosUniversais);

      // Construir prompt espec√≠fico baseado no modo
      let promptData: { systemPrompt: string; userPrompt: string };
      if (isRocketMode) {
        promptData = buildRocketPrompt(data, mentorInferido, elementosUniversais, especialidades);
      } else {
        promptData = buildFluidaPrompt(normalizedData, mentorInferido, elementosUniversais, especialidades);
      }

      // CORRE√á√ÉO: Envolver os dados na propriedade 'request' esperada pela edge function
      const requestPayload = {
        request: {
          type: 'custom',
          systemPrompt: promptData.systemPrompt,
          userPrompt: promptData.userPrompt,
          topic: normalizedData.tema,
          additionalInfo: JSON.stringify({
            tipo_de_clinica: 'estetico',
            especialidade: '',
            equipamentos: normalizedData.equipamento,
            protocolo: '',
            ticket_medio: '',
            publico_ideal: '',
            estilo_clinica: '',
            estilo_linguagem: '',
            mentor_nome: mentorInferido,
            elementos_universais: elementosUniversais,
            especialidades: especialidades,
            modo: isRocketMode ? 'rocket' : 'fluida'
          }),
          tone: normalizedData.estilo,
          marketingObjective: normalizedData.objetivo
        }
      };

      console.log('üì§ [useFluidaScript] Enviando request para Supabase function');

      // Usar Supabase functions invoke
      const { data: result, error } = await supabase.functions.invoke('generate-script', {
        body: requestPayload
      });

      // Limpar timeout se chegou at√© aqui
      clearTimeout(timeoutId);

      if (error) {
        console.error('‚ùå [useFluidaScript] Erro na fun√ß√£o Supabase:', error);
        throw new Error(`Erro na API: ${error.message}`);
      }

      if (!result) {
        console.error('‚ùå [useFluidaScript] Resultado vazio da API');
        throw new Error('Resultado vazio da API');
      }

      console.log('‚úÖ [useFluidaScript] Resultado recebido:', result);

      // Tentar fazer parse do conte√∫do se for JSON
      let scriptData = result;
      if (result.content) {
        try {
          const parsedContent = JSON.parse(result.content);
          scriptData = { ...result, ...parsedContent };
          console.log('üîÑ [useFluidaScript] Conte√∫do JSON parseado:', scriptData);
        } catch (parseError) {
          console.log('‚ÑπÔ∏è [useFluidaScript] Conte√∫do n√£o √© JSON, usando como texto');
          scriptData = {
            ...result,
            roteiro: result.content,
            formato: normalizedData.tipo_conteudo,
            emocao_central: 'criatividade',
            intencao: normalizedData.objetivo,
            objetivo: normalizedData.tema,
            mentor: mentorInferido,
            elementos_aplicados: elementosUniversais,
            especialidades_aplicadas: especialidades
          };
        }
      }

      // Garantir que temos os campos necess√°rios
      if (!scriptData.roteiro && !scriptData.content) {
        console.error('‚ùå [useFluidaScript] Roteiro vazio');
        throw new Error('Roteiro gerado est√° vazio');
      }

      // Adicionar elementos universais ao resultado
      scriptData.elementos_aplicados = scriptData.elementos_aplicados || elementosUniversais;
      scriptData.mentor = scriptData.mentor || mentorInferido;
      scriptData.especialidades_aplicadas = scriptData.especialidades_aplicadas || especialidades;
      scriptData.modo_usado = isRocketMode ? 'Rocket (10 Elementos Universais)' : 'Fluida (Akinator)';
      scriptData.is_template = false;
      scriptData.ai_improving = false;

      setResults([scriptData]);
      console.log('‚úÖ [useFluidaScript] Roteiro salvo nos resultados com elementos universais');
      
      toast.success('‚ú® Roteiro gerado com sucesso!', {
        description: `Seu roteiro ${isRocketMode ? 'Rocket' : 'FLUIDA'} est√° pronto com os elementos aplicados pelo mentor ${mentorInferido}.`
      });

      return scriptData;

    } catch (error) {
      clearTimeout(timeoutId);
      console.error('üî• [useFluidaScript] Erro ao gerar roteiro:', error);
      
      // Mensagens de erro mais espec√≠ficas
      let errorMessage = 'Erro desconhecido';
      let errorDescription = '';
      
      if (error.name === 'AbortError') {
        errorMessage = '‚è∞ Tempo esgotado';
        errorDescription = 'A gera√ß√£o est√° demorando mais que o esperado. Tente novamente com um tema mais simples.';
      } else if (error.message?.includes('API')) {
        errorMessage = 'üîß Problema na API';
        errorDescription = 'Erro na comunica√ß√£o com o servidor. Verifique sua conex√£o.';
      } else if (error.message?.includes('vazio')) {
        errorMessage = 'üìù Conte√∫do vazio';
        errorDescription = 'O roteiro n√£o foi gerado. Tente reformular o tema.';
      } else {
        errorMessage = '‚ùå Erro na gera√ß√£o';
        errorDescription = error instanceof Error ? error.message : 'Erro desconhecido';
      }
      
      toast.error(errorMessage, {
        description: errorDescription,
        action: {
          label: "Tentar novamente",
          onClick: () => generateScript(data)
        }
      });
      
      throw error;
    } finally {
      setIsGenerating(false);
      console.log('üèÅ [useFluidaScript] Gera√ß√£o finalizada');
    }
  };

  const buildRocketPrompt = (data: FluidaScriptData, mentor: string, elementos: any, especialidades: string[]) => {
    const systemPrompt = `
      Voc√™ √© o FLUIDAROTEIRISTA ROCKET ‚Äî vers√£o avan√ßada com os 10 Elementos Universais.
      
      üöÄ ELEMENTOS UNIVERSAIS APLICADOS:
      
      ${buildElementosPrompt(elementos, mentor, especialidades)}
      
      ELEMENTOS ESCOLHIDOS PELO USU√ÅRIO:
      - Storytelling: ${data.storytelling}
      - Copywriting: ${data.copywriting}
      - P√∫blico-alvo: ${data.conhecimento_publico}
      - Equipamentos: ${data.equipamentos}
      - An√°lise de Dados: ${data.analises_dados}
      - Gatilhos Mentais: ${data.gatilhos_mentais}
      - L√≥gica Argumentativa: ${data.logica_argumentativa}
      - Educa√ß√£o: ${data.premissas_educativas}
      - Empatia: ${data.mapas_empatia}
      - Headlines: ${data.headlines}
      - Ferramentas: ${data.ferramentas_especificas}
      
      ESTRUTURA OBRIGAT√ìRIA:
      1. Gancho (Headlines + Gatilhos Mentais)
      2. Conflito (Mapas de Empatia + Conhecimento do P√∫blico)
      3. Virada (L√≥gica Argumentativa + Premissas Educativas)
      4. CTA (Copywriting + Ferramentas Espec√≠ficas)
      
      INTEGRA√á√ÉO DOS ELEMENTOS:
      - Use o tipo de storytelling escolhido para estruturar a narrativa
      - Aplique o estilo de copywriting na linguagem
      - Considere o p√∫blico-alvo definido
      - Destaque os equipamentos mencionados
      - Use os gatilhos mentais selecionados
      - Mantenha a l√≥gica argumentativa escolhida
      - Inclua o n√≠vel de educa√ß√£o desejado
      - Conecte-se emocionalmente conforme o mapa de empatia
      - Crie headlines no estilo escolhido
      - Finalize com as ferramentas espec√≠ficas selecionadas
      
      IMPORTANTE: Seja CONCISO e DIRETO. M√°ximo 800 tokens de resposta.
      
      Retorne APENAS JSON v√°lido:
      {
        "roteiro": "Conte√∫do do roteiro estruturado com todos os 10 elementos aplicados",
        "formato": "carrossel",
        "emocao_central": "emo√ß√£o detectada dos elementos",
        "intencao": "inten√ß√£o principal baseada nos elementos",
        "objetivo": "Objetivo espec√≠fico do roteiro",
        "mentor": "${mentor}",
        "elementos_aplicados": ${JSON.stringify(elementos)},
        "especialidades_aplicadas": ${JSON.stringify(especialidades)},
        "modo_usado": "Rocket (10 Elementos Universais)"
      }
    `;

    const userPrompt = `
      Tema: ${data.tema}
      
      Crie um roteiro ROCKET CONCISO integrando todos os 10 elementos universais escolhidos pelo usu√°rio.
      Cada elemento deve ser aplicado de forma harmoniosa e estrat√©gica no roteiro final.
      M√ÅXIMO 500 palavras no roteiro.
    `;

    return { systemPrompt, userPrompt };
  };

  const buildFluidaPrompt = (data: any, mentor: string, elementos: any, especialidades: string[]) => {
    const systemPrompt = `
      Voc√™ √© o FLUIDAROTEIRISTA ‚Äî roteirista oficial da plataforma para cl√≠nicas est√©ticas e m√©dicas.
      
      üéØ ESTRUTURA UNIVERSAL DOS 10 ELEMENTOS (M√©todo Leandro Ladeira adaptado):
      
      ${buildElementosPrompt(elementos, mentor, especialidades)}
      
      Contexto da cl√≠nica:
      - Tipo: estetico
      - Especialidade: 
      - Equipamentos: ${data.equipamento}
      - Protocolo mais vendido: 
      - Ticket m√©dio: 
      - P√∫blico ideal: 
      - Estilo da cl√≠nica: 
      - Mentor: ${mentor}
      
      ESTRUTURA OBRIGAT√ìRIA:
      1. Gancho (Headlines + Gatilhos Mentais)
      2. Conflito (Mapas de Empatia + Conhecimento do P√∫blico)
      3. Virada (L√≥gica Argumentativa + Premissas Educativas)
      4. CTA (Copywriting + Ferramentas Espec√≠ficas)
      
      FORMATO: ${data.tipo_conteudo}
      
      IMPORTANTE: Seja CONCISO e DIRETO. M√°ximo 800 tokens de resposta.
      
      Retorne APENAS JSON v√°lido:
      {
        "roteiro": "Conte√∫do do roteiro estruturado aplicando os 10 elementos",
        "formato": "carrossel/stories/imagem/video",
        "emocao_central": "esperan√ßa/confian√ßa/urg√™ncia/etc",
        "intencao": "atrair/vender/educar/conectar",
        "objetivo": "Objetivo espec√≠fico do post",
        "mentor": "${mentor}",
        "elementos_aplicados": ${JSON.stringify(elementos)},
        "especialidades_aplicadas": ${JSON.stringify(especialidades)},
        "modo_usado": "Fluida (Akinator)"
      }
    `;

    const userPrompt = `
      Tema: ${data.tema}
      Tipo de conte√∫do: ${data.tipo_conteudo}
      Objetivo: ${data.objetivo}
      Canal: ${data.canal}
      Estilo: ${data.estilo}
      
      Crie um roteiro CONCISO seguindo o modelo FLUIDAROTEIRISTA com os 10 elementos universais aplicados 
      conforme a intensidade espec√≠fica do mentor ${mentor}. Use as especialidades 
      ${especialidades.join(', ')} para dar personalidade √∫nica ao roteiro.
      M√ÅXIMO 500 palavras no roteiro.
    `;

    return { systemPrompt, userPrompt };
  };

  const inferirEstiloDoElementos = (data: FluidaScriptData): string => {
    // Inferir estilo baseado nas escolhas dos elementos
    const storytelling = data.storytelling;
    const copywriting = data.copywriting;
    
    if (copywriting === 'cientifico_tecnico' || storytelling === 'casos_reais') {
      return 'cientifico';
    }
    if (copywriting === 'emocional_envolvente' || storytelling === 'jornada_heroi') {
      return 'emocional';
    }
    if (copywriting === 'direto_objetivo') {
      return 'direto';
    }
    if (storytelling === 'metaforas' || copywriting === 'conversacional_amigavel') {
      return 'criativo';
    }
    
    return 'criativo'; // Default
  };

  const inferirMentor = (data: any): string => {
    // Verificar se os dados est√£o definidos antes de acessar propriedades
    const objetivo = data?.objetivo || '';
    const estilo = data?.estilo || '';
    const tipoConteudo = data?.tipo_conteudo || '';
    const canal = data?.canal || '';

    console.log('üîç [inferirMentor] Dados para infer√™ncia:', { objetivo, estilo, tipoConteudo, canal });

    // L√≥gica de infer√™ncia baseada no estilo e objetivo
    if (estilo === 'direto' && objetivo.includes('vend')) {
      return 'Leandro Ladeira';
    }
    if (estilo === 'emocional' || objetivo.includes('conex√£o')) {
      return '√çcaro de Carvalho';
    }
    if (estilo === 'criativo' || tipoConteudo === 'video') {
      return 'Paulo Cuenca';
    }
    if (estilo === 'didatico' || objetivo.includes('educar')) {
      return 'Camila Porto';
    }
    if (estilo === 'humoristico' || canal.includes('stories')) {
      return 'Hyeser Souza';
    }
    if (estilo === 'publicitario' || objetivo.includes('branding')) {
      return 'Washington Olivetto';
    }
    
    console.log('üéØ [inferirMentor] Mentor padr√£o selecionado: Pedro Sobral');
    return 'Pedro Sobral';
  };

  const getDefaultElementos = () => {
    return {
      storytelling: 7,
      copywriting: 8,
      conhecimento_publico: 6,
      analises_dados: 5,
      gatilhos_mentais: 7,
      logica_argumentativa: 6,
      premissas_educativas: 7,
      mapas_empatia: 8,
      headlines: 9,
      ferramentas_especificas: 6
    };
  };

  const buildElementosPrompt = (elementos: any, mentor: string, especialidades: string[]): string => {
    if (!elementos) return '';

    return `
1. STORYTELLING (Intensidade: ${elementos.storytelling || 7}/10)
   ${(elementos.storytelling || 7) >= 8 ? '- Narrativas envolventes e emocionais' : (elementos.storytelling || 7) >= 6 ? '- Hist√≥rias simples e diretas' : '- Elementos narrativos sutis'}

2. COPYWRITING (Intensidade: ${elementos.copywriting || 8}/10)
   ${(elementos.copywriting || 8) >= 8 ? '- Textos persuasivos e impactantes' : (elementos.copywriting || 8) >= 6 ? '- Copy clara e objetiva' : '- Linguagem simples e acess√≠vel'}

3. CONHECIMENTO DO P√öBLICO-ALVO (Intensidade: ${elementos.conhecimento_publico || 6}/10)
   ${(elementos.conhecimento_publico || 6) >= 8 ? '- Segmenta√ß√£o precisa e personalizada' : (elementos.conhecimento_publico || 6) >= 6 ? '- Perfil b√°sico definido' : '- P√∫blico geral'}

4. AN√ÅLISES E DADOS (Intensidade: ${elementos.analises_dados || 5}/10)
   ${(elementos.analises_dados || 5) >= 8 ? '- M√©tricas detalhadas e otimiza√ß√£o' : (elementos.analises_dados || 5) >= 6 ? '- Dados b√°sicos de performance' : '- Foco na criatividade'}

5. GATILHOS MENTAIS (Intensidade: ${elementos.gatilhos_mentais || 7}/10)
   ${(elementos.gatilhos_mentais || 7) >= 8 ? '- Escassez, urg√™ncia, prova social' : (elementos.gatilhos_mentais || 7) >= 6 ? '- Gatilhos sutis' : '- Persuas√£o natural'}

6. L√ìGICA ARGUMENTATIVA (Intensidade: ${elementos.logica_argumentativa || 6}/10)
   ${(elementos.logica_argumentativa || 6) >= 8 ? '- Argumentos estruturados e convincentes' : (elementos.logica_argumentativa || 6) >= 6 ? '- Raz√µes claras' : '- Abordagem emocional'}

7. PREMISSAS EDUCATIVAS (Intensidade: ${elementos.premissas_educativas || 7}/10)
   ${(elementos.premissas_educativas || 7) >= 8 ? '- Educa√ß√£o antes da oferta' : (elementos.premissas_educativas || 7) >= 6 ? '- Informa√ß√µes b√°sicas' : '- Foco na a√ß√£o'}

8. MAPAS DE EMPATIA (Intensidade: ${elementos.mapas_empatia || 8}/10)
   ${(elementos.mapas_empatia || 8) >= 8 ? '- Perspectiva profunda do cliente' : (elementos.mapas_empatia || 8) >= 6 ? '- Compreens√£o b√°sica' : '- Abordagem direta'}

9. HEADLINES (Intensidade: ${elementos.headlines || 9}/10)
   ${(elementos.headlines || 9) >= 8 ? '- T√≠tulos magn√©ticos e irresist√≠veis' : (elementos.headlines || 9) >= 6 ? '- T√≠tulos claros e atrativos' : '- T√≠tulos simples'}

10. FERRAMENTAS ESPEC√çFICAS (Intensidade: ${elementos.ferramentas_especificas || 6}/10)
    ${(elementos.ferramentas_especificas || 6) >= 8 ? '- CTAs, funis, v√≠deos de venda' : (elementos.ferramentas_especificas || 6) >= 6 ? '- CTAs b√°sicos' : '- Chamadas simples'}

üé® ESPECIALIDADES DO MENTOR ${mentor}: ${especialidades.join(', ')}
    `;
  };

  const applyDisneyMagic = async (script: any) => {
    console.log('‚ú® [useFluidaScript] Aplicando Disney Magic com anima√ß√£o');
    
    // Transforma√ß√µes Disney mais criativas
    const disneyTransformations = {
      'tratamento': 'jornada m√°gica de transforma√ß√£o',
      'procedimento': 'ritual de beleza encantado',
      'resultado': 'metamorfose dos sonhos',
      'cliente': 'princesa especial',
      'clientes': 'princesas especiais',
      'paciente': 'hero√≠na da sua hist√≥ria',
      'consulta': 'encontro m√°gico',
      'sess√£o': 'cap√≠tulo encantado',
      'aplica√ß√£o': 'toque de varinha m√°gica',
      'equipamento': 'varinha tecnol√≥gica',
      'laser': 'raio de luz encantado',
      'botox': 'po√ß√£o da juventude',
      'preenchimento': 'elixir da beleza',
      'harmoniza√ß√£o': 'sinfonia da perfei√ß√£o'
    };

    let disneyScript = { ...script };
    let transformedText = script.roteiro;

    // Aplicar transforma√ß√µes
    Object.entries(disneyTransformations).forEach(([original, disney]) => {
      const regex = new RegExp(original, 'gi');
      transformedText = transformedText.replace(regex, disney);
    });

    // Adicionar elementos Disney ao in√≠cio e fim
    const disneyIntro = "‚ú® Era uma vez uma hist√≥ria de transforma√ß√£o m√°gica...\n\n";
    const disneyOutro = "\n\nüè∞ E assim, sua jornada dos sonhos come√ßa aqui. Venha viver seu conto de fadas! ‚ú®";

    disneyScript = {
      ...disneyScript,
      roteiro: disneyIntro + transformedText + disneyOutro,
      emocao_central: 'encantamento',
      mentor: 'Fada Madrinha Disney ‚ú®üè∞',
      elementos_aplicados: {
        ...script.elementos_aplicados,
        storytelling: 10,
        mapas_empatia: 10,
        headlines: 10
      },
      disney_applied: true
    };
    
    setResults([disneyScript]);
    
    toast.success('üè∞ Disney Magic aplicada!', {
      description: 'Seu roteiro agora tem a magia Disney com elementos universais potencializados.'
    });

    return disneyScript;
  };

  const generateImage = async (script: any) => {
    console.log('üñºÔ∏è [useFluidaScript] Gerando imagem para script');
    
    try {
      const { data, error } = await supabase.functions.invoke('generate-image', {
        body: { script }
      });

      if (error) {
        throw error;
      }

      if (data.success) {
        toast.success('üñºÔ∏è Imagem gerada!', {
          description: 'Sua imagem foi criada com sucesso.'
        });
        
        // Abrir imagem em nova janela
        window.open(data.imageUrl, '_blank');
      } else {
        throw new Error(data.error);
      }
    } catch (error) {
      console.error('üî• Erro ao gerar imagem:', error);
      toast.error('‚ùå Erro na gera√ß√£o de imagem', {
        description: 'N√£o foi poss√≠vel gerar a imagem. Tente novamente.'
      });
    }
  };

  const clearResults = () => {
    console.log('üóëÔ∏è [useFluidaScript] Limpando resultados');
    setResults([]);
    setAiImproving(false);
  };

  const generateAudio = async (script: any) => {
    console.log('üéôÔ∏è [useFluidaScript] Gerando √°udio para script');
    toast.info('üéôÔ∏è Gera√ß√£o de √°udio', {
      description: 'Funcionalidade em desenvolvimento.'
    });
  };

  return {
    results,
    isGenerating,
    aiImproving,
    showingTemplate,
    generateScript,
    applyDisneyMagic,
    clearResults,
    generateImage,
    generateAudio
  };
};
